// ============================================================================
//   Ver  :| Author :| Mod. Date :| Changes Made:
//   V1.1 :| Alexandra Du :| 06/01/2016:| Added Verilog file
// ============================================================================


//=======================================================
//  This code is generated by Terasic System Builder
//=======================================================

`define ENABLE_ADC_CLOCK
`define ENABLE_CLOCK1
`define ENABLE_CLOCK2
`define ENABLE_SDRAM
`define ENABLE_HEX0
`define ENABLE_HEX1
`define ENABLE_HEX2
`define ENABLE_HEX3
`define ENABLE_HEX4
`define ENABLE_HEX5
`define ENABLE_KEY
`define ENABLE_LED
`define ENABLE_SW
`define ENABLE_VGA
`define ENABLE_ACCELEROMETER
`define ENABLE_ARDUINO
`define ENABLE_GPIO

module DE10_LITE_Golden_Top(

//////////// ADC CLOCK: 3.3-V LVTTL //////////
`ifdef ENABLE_ADC_CLOCK
input           ADC_CLK_10,
`endif
//////////// CLOCK 1: 3.3-V LVTTL //////////
`ifdef ENABLE_CLOCK1
input           MAX10_CLK1_50,
`endif
//////////// CLOCK 2: 3.3-V LVTTL //////////
`ifdef ENABLE_CLOCK2
input           MAX10_CLK2_50,
`endif

//////////// SDRAM: 3.3-V LVTTL //////////
`ifdef ENABLE_SDRAM
output    [12:0] DRAM_ADDR,
output     [1:0] DRAM_BA,
output           DRAM_CAS_N,
output           DRAM_CKE,
output           DRAM_CLK,
output           DRAM_CS_N,
inout    [15:0] DRAM_DQ,
output           DRAM_LDQM,
output           DRAM_RAS_N,
output           DRAM_UDQM,
output           DRAM_WE_N,
`endif

//////////// SEG7: 3.3-V LVTTL //////////
`ifdef ENABLE_HEX0
output     [7:0] HEX0,
`endif
`ifdef ENABLE_HEX1
output     [7:0] HEX1,
`endif
`ifdef ENABLE_HEX2
output     [7:0] HEX2,
`endif
`ifdef ENABLE_HEX3
output     [7:0] HEX3,
`endif
`ifdef ENABLE_HEX4
output     [7:0] HEX4,
`endif
`ifdef ENABLE_HEX5
output     [7:0] HEX5,
`endif

//////////// KEY: 3.3 V SCHMITT TRIGGER //////////
`ifdef ENABLE_KEY
input     [1:0] KEY,
`endif

//////////// LED: 3.3-V LVTTL //////////
`ifdef ENABLE_LED
output     [9:0] LEDR,
`endif

//////////// SW: 3.3-V LVTTL //////////
`ifdef ENABLE_SW
input     [9:0] SW,
`endif

//////////// VGA: 3.3-V LVTTL //////////
`ifdef ENABLE_VGA
output     [3:0] VGA_B,
output     [3:0] VGA_G,
output           VGA_HS,
output     [3:0] VGA_R,
output           VGA_VS,
`endif

//////////// Accelerometer: 3.3-V LVTTL //////////
`ifdef ENABLE_ACCELEROMETER
output           GSENSOR_CS_N,
input     [2:1] GSENSOR_INT,
output           GSENSOR_SCLK,
inout           GSENSOR_SDI,
inout           GSENSOR_SDO,
`endif

//////////// Arduino: 3.3-V LVTTL //////////
`ifdef ENABLE_ARDUINO
inout    [15:0] ARDUINO_IO,
inout           ARDUINO_RESET_N,
`endif

//////////// GPIO, GPIO connect to GPIO Default: 3.3-V LVTTL //////////
`ifdef ENABLE_GPIO
inout    [35:0] GPIO
`endif
);



//=======================================================
//  REG/WIRE declarations
//=======================================================


//=======================================================
//  Structural coding
//=======================================================



project (MAX10_CLK2_50, KEY[0], KEY[1], HEX0[6:0], HEX1[6:0], HEX2[6:0], HEX3[6:0], HEX4[6:0], HEX5[6:0], SW[7:2], SW[1], SW[0], SW[9:8]);



endmodule

//clock module
module clockk (clk, clkIntime, break, reset, Cout);

input [16:0] clkIntime;
input clk, break, reset;
output [16:0] Cout;  

reg [16:0] outputVal = 17'd0;
reg [31:0] cycleCount = 32'd0;  
reg Pushbutton = 1'd0; 
reg phase = 1'd1;  
reg defaultVal = 2'd0;
reg [16:0] cOut_data= 17'd0;  
   
// Total seconds in a day
parameter dayinSeconds = 17'd86400;  
// Clock cycle for 1-second delay
parameter Seconds = 32'd50000000;


always @(negedge clk)
begin
    outputVal <= cOut_data + clkIntime; // Update output value
end
 
assign Cout = outputVal;
 
 
 
always @(negedge reset or negedge break or negedge clk)
begin
    if (reset == 0) begin 
	 cycleCount <= 32'd0;	 
    Pushbutton <= 1'd0;
	 cOut_data<= 17'd0;
	 phase <= 1'd1;
	 end  
	 
    else begin
    if (break == 0) begin
    Pushbutton <= (defaultVal == 2'd0) ? 1'd0 : 1'd1;
    end
	 
    else begin if ((defaultVal != 2'd0)&&(Pushbutton == 1'd1))
    begin
    Pushbutton <= 1'd0;  
    phase <= ~phase;  

    if (phase == 1'd1) begin
	 cycleCount <= cycleCount + 32'd1;
	 
    if (cycleCount >= Seconds - 32'd1) begin
    cycleCount <= 32'd0;
	 cOut_data <= ((cOut_data+ clkIntime) >= 17'd86399) ? (17'd0 - clkIntime) : cOut_data+ 17'd1;
   
    if (defaultVal <= 2'd0) begin 
	 Pushbutton <= 1'd0;
    defaultVal <= defaultVal + 2'd1;

    end
    end
    end  
    end
	 
    else begin 
	 
	 if (phase == 1'd1) begin
	 cycleCount <= cycleCount + 32'd1;

    if (cycleCount >= Seconds - 32'd1) begin
    cycleCount <= 32'd0;

    cOut_data<= ((cOut_data+ clkIntime) >= 17'd86399) ? (17'd0 - clkIntime) : cOut_data+ 17'd1;

    if (defaultVal <= 2'd0) begin
    defaultVal <= defaultVal + 2'd1;

    Pushbutton <= 1'd0;
    end
    end
    end
    end
    end
    end
end    
 

endmodule

//countdown module
module countdown(clk, Cout, break, reset, clkIntime, secondBlinkerOutput, minuteBlinkerOut, hourBlinkerOut);
 

input clk, break, reset;
input [16:0] clkIntime;
output secondBlinkerOutput, minuteBlinkerOut, hourBlinkerOut;
output [16:0] Cout;

reg hourblinker= 1'd0;
reg minuteblinker = 1'd0;
reg sec_blinker = 1'd0;
reg [16:0] cOut_data= 17'd0;
reg [16:0] outputVal = 17'd0;
reg [31:0] cycleCount = 32'd0;  
reg defaultVal = 2'd0;
reg phase = 1'd1;  
reg countdownEnd = 1'd0;
reg Pushbutton = 1'd0;


parameter Seconds = 32'd50000000;  


always @(negedge clk)
begin
    outputVal <= (clkIntime == 17'd0) ? (17'd0) : clkIntime - cOut_data; // remaining time caculated
end

always @(negedge reset or negedge break or negedge clk)
begin
    if (reset == 0)  
    begin    
   
	cOut_data <= 17'd0;
cycleCount <= 32'd0;
    Pushbutton <= 1'd0;
phase <= 1'd1;
    countdownEnd <= 1'd0;

sec_blinker <= countdownEnd ? (~sec_blinker) : (1'd0);
minuteblinker <= countdownEnd ? (~minuteblinker) : (1'd0);
    hourblinker <= countdownEnd ? (~hourblinker) : (1'd0);
   
   
 
    end    
    else  
    begin
    if (break == 0)  

    begin
    Pushbutton <= (defaultVal == 2'd0) ? 1'd0 : 1'd1;

sec_blinker <= 1'd0;
minuteblinker <= 1'd0;
hourblinker<= 1'd0;
   
   
    end
    else
    begin

    if ((defaultVal != 2'd0) &&(Pushbutton == 1'd1))  
	 begin
    Pushbutton <= 1'd0;  
    phase <= ~phase;

    if (phase == 1'd1)  
    begin
	 cycleCount <= cycleCount + 32'd1;
    
	 if (cycleCount >= Seconds - 32'd1)    
    begin
    cycleCount <= 32'd0;
	 cOut_data <= cOut_data + 17'd1;

    if(cOut_data >= clkIntime - 17'd1)
    begin

    countdownEnd <= 1'd1;
	 cOut_data <= clkIntime;
   
sec_blinker <= countdownEnd ? (~sec_blinker) : (1'd0);
minuteblinker <= countdownEnd ? (~minuteblinker) : (1'd0);
hourblinker <= countdownEnd ? (~hourblinker) : (1'd0);
   
   
   
    end
   
    if (defaultVal <= 2'd0)
    begin

    Pushbutton <= 1'd0;
defaultVal <= defaultVal + 2'd1;

    end
    end
    end  
    end
    else  
    begin

    if (phase == 1'd1)  
    begin
   
    cycleCount <= cycleCount + 32'd1;
    if (cycleCount >= Seconds - 32'd1)    
    begin

    cycleCount <= 32'd0;
    cOut_data <= cOut_data + 17'd1;

    if(cOut_data >= clkIntime - 17'd1)
    begin

    countdownEnd <= 1'd1;
cOut_data <= clkIntime;
   
sec_blinker <= countdownEnd ? (~sec_blinker) : (1'd0);
minuteblinker <= countdownEnd ? (~minuteblinker) : (1'd0);
hourblinker <= countdownEnd ? (~hourblinker) : (1'd0);
   
   
    end
   
    if (defaultVal <= 2'd0) begin

    Pushbutton <= 1'd0;  
	 defaultVal <= defaultVal + 2'd1;
   
    end
    end
    end
    end
    end
    end
end    
 
 


assign Cout = outputVal;
assign secondBlinkerOutput = (clkIntime == 17'd0) ?
1'd0 :
sec_blinker;
assign minuteBlinkerOut = (clkIntime == 17'd0) ?
1'd0 :
minuteblinker;
assign hourBlinkerOut = (clkIntime == 17'd0) ?
1'd0 :
hourblinker;
 
endmodule


//stopwatch module
module stopwatch(clk, Cout, reset, sw, loop, strtStopwatch);
 

reg defaultVal = 2'd0;
reg [3:0] nextLoop = 4'd1;
reg Pushbutton = 1'd0;
reg [11:0] loopdata [18:0];
reg [18:0] outputVal = 19'd0;
reg [31:0] cycleCount = 32'd0;          
reg [18:0] cOut_data= 19'd0;  


input clk, loop, reset, strtStopwatch;
output [18:0] Cout;
input [3:0] sw;  
 
parameter clkSecCycle = 32'd500000;

always @ (posedge clk)  
begin

    if (sw == 4'd0)
    outputVal <= (cOut_data >= 19'd360000) ?
(cOut_data - 19'd360000) :
(cOut_data);
    else
    outputVal <= (cOut_data >= 19'd360000) ?
((nextLoop >= 4'd3) ?
((loopdata[sw]==19'd0) ?
(19'd0):(loopdata[sw] - loopdata[sw - 4'd1])) :
(loopdata[sw] - 19'd360000)) :
((nextLoop >= 4'd3) ?
((loopdata[sw] == 19'd0) ?
(19'd0) :
(loopdata[sw] - loopdata[sw - 4'd1])) :
(loopdata[sw]));
end


always @(negedge reset or negedge loop or negedge clk)
begin

    if (reset == 0)  
    begin    
   
cOut_data <= 19'd0;
Pushbutton <= 1'd0;
cycleCount <= 32'd0;
     nextLoop <= 4'd1;
 
    loopdata[0] <= 19'd0;
    loopdata[1] <= 19'd0;
    loopdata[2] <= 19'd0;
    loopdata[3] <= 19'd0;
    loopdata[4] <= 19'd0;
    loopdata[5] <= 19'd0;
    loopdata[6] <= 19'd0;
    loopdata[7] <= 19'd0;
    loopdata[8] <= 19'd0;
    loopdata[9] <= 19'd0;
    loopdata[10] <= 19'd0;
    loopdata[11] <= 19'd0;


    end    
    else    
    begin
    if(loop == 0)  
    begin

    Pushbutton <= (defaultVal==2'd0) ?
(1'd0) :
(1'd1);
    end
    else  
    begin

    if (strtStopwatch == 1)  
    begin

    if((defaultVal != 2'd0) && (Pushbutton == 1'd1))  
    begin

     defaultVal <= 1'd1;
Pushbutton <= 1'd0;
   
    loopdata[nextLoop] <= (nextLoop >= 4'd11) ?
(loopdata[nextLoop]) :
cOut_data;
    nextLoop <= (nextLoop >= 4'd11) ?
(nextLoop) :
nextLoop + 4'd1;  
    end

    else  
    begin

    loopdata[nextLoop] <= 19'd0;
defaultVal <= 2'd1;
   
    nextLoop <= nextLoop;
    end
    cycleCount <= cycleCount + 32'd1;

    if(cycleCount >= clkSecCycle - 32'd1)  
    begin

    cOut_data <= cOut_data + 19'd1;
cycleCount <= 32'd0;
   
    end
    else
    begin

    cOut_data <= cOut_data;
    end  
    end
    else  
    begin

    if((defaultVal != 2'd0) && (Pushbutton == 1'd1))  
    begin

    defaultVal <= 2'd1;
Pushbutton <= 1'd0;

    loopdata[nextLoop] <= (nextLoop >= 4'd11) ?
(loopdata[nextLoop]) :
cOut_data;
    nextLoop <= (nextLoop >= 4'd11) ?
(nextLoop) :

nextLoop + 4'd1;
    end
    else  
    begin

    loopdata[nextLoop] <= 19'd0;
defaultVal <= 2'd1;
    nextLoop <= nextLoop;

    end
    cOut_data<= cOut_data;

cycleCount <= cycleCount;
     
    end
    end    
    end
end    
 



assign Cout = outputVal;
endmodule
 

//user clock input module
module userIn(clk, Cout, reset, clicker, inputVal, secondBlinkerOutput, minuteBlinkerOut, hourBlinkerOut);


reg sec_blinker = 1'b0;
reg minuteblinker = 1'b0;  
reg hourblinker= 1'b0;

wire [16:0] inputValSwitch;
reg cv = 11'd0;
assign inputValSwitch = {cv, inputVal};  

reg [16:0] second = 17'd0;
reg [16:0] min = 17'd0;
reg [16:0] hour= 17'd0;
reg [1:0] defaultVal = 2'd0;
reg Pushbutton = 1'd0; 
reg [1:0] numPush = 2'd0;
reg [31:0] cycleCount = 32'd0;   
 

input [5:0] inputVal;
input clk, reset, clicker;
output [16:0] Cout;
output secondBlinkerOutput, minuteBlinkerOut, hourBlinkerOut;

parameter halfSeconds = 32'd25000000;  

parameter Seconds = 32'd50000000;


always @(posedge clk, negedge clicker, negedge reset)

begin

    if(reset == 0)  
    begin

    second = 17'd0;
    min = 17'd0;
    hour = 17'd0;

defaultVal = 2'd0;

cycleCount = 32'd0;

Pushbutton = 1'd0;
    numPush = 2'd0;
   
cv = 11'd0;

    sec_blinker = 1'b0;
    minuteblinker = 1'b0;  
    hourblinker = 1'b0;

    end
    else  
    begin

    if (clicker == 0)  
    begin

    Pushbutton <= (defaultVal == 2'd0) ? 1'd0 : 1'd1;
	 defaultVal <= defaultVal;
	 
	 second <= second;
    min <= min;
    hour<= hour;
	 cycleCount <= cycleCount + 32'd1;
	 numPush <= numPush;

    sec_blinker <= sec_blinker;
	 minuteblinker <= minuteblinker;
	 hourblinker <= hourblinker;
     
    end
    else  
    begin

    if ((defaultVal != 2'd0) && (Pushbutton == 1'd1))  
    begin

    Pushbutton <= 1'd0;  
   
    if (cycleCount >= Seconds - 32'd1)    
    begin

    sec_blinker <= 1'd0;
    minuteblinker <= 1'd0;
    hourblinker <= 1'd0;
	 cycleCount <= 32'd0;
   
    end
    else if (cycleCount >= halfSeconds - 32'd1)
    begin
sec_blinker <= (numPush == 2'd2) ? 1'd1 : 1'd0;
minuteblinker <= (numPush == 2'd1) ? 1'd1 : 1'd0;
hourblinker <= (numPush == 2'd0) ? 1'd1 : 1'd0;

    cycleCount <= cycleCount + 32'd1;
    end
    else
    begin
	 
	 sec_blinker <= sec_blinker;
	 minuteblinker <= minuteblinker;
	 hourblinker <= hourblinker;
	 cycleCount <= cycleCount + 32'd1;
 
    end

    if(numPush == 2'd0)
    begin

    numPush <= numPush + 2'd1;
	 second <= second;
	 min <= min;
	 hour <= inputValSwitch;
   
    end
    else if (numPush == 2'd1)
    begin

    numPush <= numPush + 2'd1;
	 second <= second;
	 min <= inputValSwitch;
	 hour <= hour;
   
    end
    else if (numPush == 2'd2)
    begin

    numPush <= numPush + 2'd1;
 
second <= inputValSwitch;
    min <= min;
    hour <= hour;

    end
    else  
    begin

    numPush <= numPush;
	 second <= second;
    min <= min;
    hour <= hour;
   
    end
    end
    else  
    begin

    numPush <= numPush;
	 Pushbutton <= 1'd0;
	 defaultVal <= 2'd1;  
     
   
    if (cycleCount >= Seconds - 32'd1)    
    begin

    sec_blinker <= 1'd0;
	 minuteblinker <= 1'd0;
	 hourblinker <= 1'd0;
	 
	 cycleCount <= 32'd0;
 
    end
    else if (cycleCount >= halfSeconds - 32'd1)
    begin

    sec_blinker <= (numPush == 2'd2) ? 1'd1 : 1'd0;
	 minuteblinker <= (numPush == 2'd1) ? 1'd1 : 1'd0;
	 hourblinker <= (numPush == 2'd0) ? 1'd1 : 1'd0;
	 
	 cycleCount <= cycleCount + 32'd1;
 
    end
    else
    begin

    sec_blinker <= sec_blinker;
	 minuteblinker <= minuteblinker;
	 hourblinker <= hourblinker;
	 
	 cycleCount <= cycleCount + 32'd1;

    end
    if(numPush == 2'd0)
    begin

    second <= second;
	 min <= min;
	 hour <= inputValSwitch;
   
    end
    else if (numPush == 2'd1)
    begin

    second <= second;
	 min <= inputValSwitch;
    hour <= hour;

    end
    else if (numPush == 2'd2)
    begin

    second <= inputValSwitch;
    min <= min;
    hour <= hour;

    end
    else
    begin

    second <= second;
    min <= min;
    hour <= hour;

    end
    end
    end
    end
end


assign secondBlinkerOutput = sec_blinker;
assign minuteBlinkerOut = minuteblinker;
assign hourBlinkerOut = hourblinker;

assign Cout = ( second + (min * 17'd60) + (hour * 17'd3600));

 
endmodule